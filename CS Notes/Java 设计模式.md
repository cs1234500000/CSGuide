## Java 设计模式

[(1条消息) 设计模式面试题（总结最全面的面试题！！！）_小杰爱吃蛋的博客-CSDN博客_设计模式面试题](https://blog.csdn.net/weixin_43122090/article/details/105462226)

1. 生产者消费者模型

   生产者/消费者模型的优点
   1、解耦，即降低生产者和消费者之间的依赖关系。
   例如上述写信的例子，如果不使用邮筒（也就是缓区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须得认识谁是邮递员，才能把信给他（光凭身上穿的制服，万一有人假冒，就惨了 ）。这就产生和你和邮递员之间的依赖（相当于生产者和消费者的强耦合）。万一哪天邮递员换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮筒相对来说比较固定，你依赖它的成本就比较低（相当于和缓冲区之间的弱耦合）。

   2、支持并发，即生产者和消费者可以是两个独立的并发主体，互不干扰的运行。
   从寄信的例子来看。如果没有邮筒，你得拿着信傻站在路口等邮递员过来收（相当于生产者阻塞）；又或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。不管是哪种方法，效率都比较低。

   3、支持忙闲不均，如果制造数据的速度时快时慢，缓冲区可以对其进行适当缓冲。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。
   为了充分复用，我们再拿寄信的例子来说事。假设邮递员一次只能带走1000封信。万一某次碰上情人节（也可能是圣诞节）送贺卡，需要寄出去的信超过1000封，这时候邮筒这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮筒中，等下次过来时再拿走。
   

1. #### 设计模式种类

   创建型模式，共五种：**工厂方法**模式、抽象工厂模式、**单例**模式、建造者模式、原型模式。

   结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

   行为型模式，共十一种：策略模式、**模板方法**模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
   
2. #### 单例模式

   定义：在应用这个模式时，单例对象的类必须保证**只有一个实例**存在，整个系统只能使用一个对象实例。
   应用：

   1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。
   2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。
   3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制
   4. Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个
   5. windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。

   优点：

   1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例
   2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。
      提供了对唯一实例的受控访问。
   3. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。
   4. 允许可变数目的实例。
   5. 避免对共享资源的多重占用。

   缺点：

   1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
   2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
   3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。
   4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

   ```java
   class Singleton {
       private static Singleton instance = new Singleton();
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

   ```java
   // 单例模式-延迟加载版
   class SingletonLazy {
       private static SingletonLazy instance;
       public static SingletonLazy getInstance() {
           if (instance == null) {
               instance = new SingletonLazy();
           }
           return instance;
       }
   }
   ```

   

3. #### 工厂模式

   定义：它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时<u>不会对客户端暴露创建逻辑</u>，并且是通过使用一个共同的接口来指向新创建的对象。实现了<u>创建者和调用者分离</u>，工厂模式分为简单工厂、工厂方法、抽象工厂模式

   优点：工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

   1. 简单工厂 ：用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 

      简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。

      - 优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。
      - 缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则

      ```java
      public interface Car {
      	public void run();
      }
      
      public class Bmw implements Car {
      	public void run() {
      		System.out.println("我是宝马汽车...");
      	}
      }
      
      public class AoDi implements Car {
      	public void run() {
      		System.out.println("我是奥迪汽车..");
      	}
      }
      
      public class CarFactory {
      
      	 public static Car createCar(String name) {
      		if ("".equals(name)) {
                   return null;
      		}
      		if(name.equals("奥迪")){
      			return new AoDi();
      		}
      		if(name.equals("宝马")){
      			return new Bmw();
      		}
      		return null;
      	}
      }
      ```

   2. 工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）  

      工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，**核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做**。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节

      ```java
      public interface Car {
      	public void run();
      }
      public interface CarFactory {
      	Car createCar();
      }
      public class AoDi implements Car {
      	public void run() {
      		System.out.println("我是奥迪汽车..");
      	}
      }
      public class Bmw implements Car {
      	public void run() {
      		System.out.println("我是宝马汽车...");
      	}
      }
      public class AoDiFactory implements CarFactory {
      	public Car createCar() {
      		return new AoDi();
      	}
      }
      public class BmwFactory implements CarFactory {
      	public Car createCar() {
      		return new Bmw();
      	}
      }
      ```

   3. 抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）

      抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。

      

4. #### 代理模式

   定义：通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AOP的微实现)。 代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似

   应用：Spring AOP、日志打印、异常处理、事务控制、权限控制等

   分类：

   1. 静态代理(静态定义代理类)

      简单代理模式，是动态代理的理论基础。常见使用在代理模式

   2. 动态代理(动态生成代理类，也称为Jdk自带动态代理)

      使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。

   3. Cglib 、javaassist（字节码操作库）

      cglib动态代理：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）

   

5. #### 建造者模式

   定义：是将一个复杂的对象的**构建与它的表示分离**，使得同样的构建过程可以创建不同的方式进行创建。

   工厂类模式是提供的是创建单个类的产品，而建造者模式则是将各种产品集中起来进行管理，用来具有不同的属性的产品

   角色：

   1. uilder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。
   2. ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。
   3. Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。
   4. Product：要创建的复杂对象。

   场景：

   1. 需要生成的对象具有复杂的内部结构。
   2. 需要生成的对象内部属性本身相互依赖。

   与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

   JAVA 中的 StringBuilder就是建造者模式创建的，他把一个单个字符的char数组组合起来

   Spring不是建造者模式，它提供的操作应该是对于字符串本身的一些操作，而不是创建或改变一个字符串。
   
   

6. #### 模板模式

   定义：定义一个操作中的算法骨架（父类），而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构来重定义该算法的

   用途：实现一些操作时，整体步骤很固定，但是就是其中一小部分需要改变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。

   应用：
   数据库访问的封装、Junit单元测试、servlet中关于doGet/doPost方法的调用等等

7. #### 外观模式

   定义：也叫门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。使用外观模式，他外部看起来就是一个接口，其实他的内部有很多复杂的接口已经被实现。

   例子：
   用户注册完之后，需要调用阿里短信接口、邮件接口、微信推送接口。

8. #### 原型模式

   定义：原型设计模式简单来说就是克隆。原型表明了有一个样板实例，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。

   应用：

   1. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝避免这些消耗。
   2. 通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。
   3. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。

   使用方法：

   1. 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。
   2. 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此Prototype类需要将clone方法的作用域修改为public类型。

   类别：

   1. （浅复制）只是拷贝了基本类型的数据，而引用类型数据，只是拷贝了一份引用地址。
   2. （深复制）在计算机中开辟了一块新的内存地址用于存放复制的对象。

   ```java
   import java.util.ArrayList;
   
   public class User implements Cloneable {
       private String name;
       private String password;
       private ArrayList<String> phones;
   
       protected User clone() {
           try {
               User user = (User) super.clone();
               //重点，如果要连带引用类型一起复制，需要添加底下一条代码，如果不加就对于是复制了引用地址
               user.phones = (ArrayList<String>) this.phones.clone();//设置深复制
               return user;
           } catch (CloneNotSupportedException e) {
               e.printStackTrace();
           }
           return null;
       }	
   }
   ```

   

9. #### 策略模式

   定义：定义了一系列的<u>算法或逻辑或相同意义</u>的操作，并将每一个算法、逻辑、操作封装起来，而且使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛）我觉得主要是为了 简化 if…else 所带来的复杂和难以维护。

   应用：
   策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。

   1. 例如：我要做一个不同会员打折力度不同的三种策略，初级会员，中级会员，高级会员（三种不同的计算）。
   2. 例如：我要一个支付模块，我要有微信支付、支付宝支付、银联支付等

   优点： 

   1. 算法可以自由切换。
   2. 避免使用多重条件判断。 
   3. 扩展性非常良好。

   缺点： 

   1. 策略类会增多。 
   2. 所有策略类都需要对外暴露。
      
      

10. ####  观察者模式

    定义：先讲什么是行为性模型，行为型模式关注的是系统中对象之间的相互交互，解决系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。

    观察者模式，是一种行为性模型，又叫**发布-订阅**模式，他定义对象之间一种一对多的依赖关系，使得当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

    职责：观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。

    实现：

    1. 推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。
    2. 拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。

    应用：

    1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。
    2. 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

