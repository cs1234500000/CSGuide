## MySQL

1. #### 索引是什么？

   索引是一种特殊的文件，他们包含着对数据表里所有记录的<u>引用指针</u>。

   索引是一种<u>数据结构</u>。数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树及变种B+树。索引是一个文件，需要占据物理空间。

   MySQL索引的建立对于高效运行是很重要的，大大提高检索速度。

   

2. ####  索引的优缺点

   优点：

   1. 可以大大加快数据的检索速度
   2. 可以通过使用索引，使用优化隐藏器，提高系统的性能

   缺点：

   1. 创建索引和维护索引需要耗费时间，增删改查时需要动态维护索引，降低执行效率

   2. 索引需要占据物理空间

      

3. ####  MySQL有哪几种索引类型

   1. BTree索引，Hash索引，full-index全文索引，R-tree索引

   2. 普通索引，唯一索引，复合索引

      普通索引：<u>一个索引只包含单个列</u>，一个表中可以有多个单列索引

      唯一索引：索引列的值必须唯一，但允许有空值

      复合索引：<u>多列值组成一个索引</u>，专门用于组合搜索，效率大于索引合并

      聚簇索引：并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引就是在同一个结构中保存了B-Tree索引

      非聚簇索引

      

4. #### 索引的底层实现？

   **Hash索引**

   基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有索引列计算一个hash code，并且hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针

   **B-Tree索引（MySQL使用B+Tree）**

   存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中

   **B+Tree索引**

   是B-Tree的改进版本。数据都在叶子节点上，并且**增加了顺序访问指针**，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获得所有节点，相比之下B+Tree效率更高

   1. n颗子树的节点包含n个关键字，不用来保存数据而是保存数据的索引

   2. 所有的叶子节点包含了**全部关键字的信息**，及**指向含这些关键字记录的指针**，且叶子节点本身依关键字的大小自小二大**顺序链接**

   3. 所有的非终端节点可以看成索引部分，结点中仅含其子树中的最大（或最小）关键字

   4. B+树种，数据对象的插入和删除仅在叶节点上运行

   5. B+树有2个头指针，一个树的根节点，一个是最小关键码的叶节点

      

5. #### 为什么索引结构默认使用B+Tree，而不是B-Tree, Hash, 二叉树，红黑树

   B-Tree:

   1. B+树的磁盘读写代价更低。B+树的<u>内部节点并没有指向关键字具体信息的指针</u>，那么**盘块所能容纳的关键字数量也越多，IO降低**。
   2. 由于B+树的数据都存储在叶子结点中，方便区间查询。

   Hash:

   1. <u>没有顺序，IO复杂度高</u>； 
   2. 只有Memory存储引擎显式支持哈希索引 ； 
   3. 不支持范围查询 ； 
   4. 不能像B+Tree索引一样利用索引完成排序 ； 
   5. Hash索引在查询等值时非常快 ； 
   6. Hash索引始终索引的所有列的全部内容，所以不支持部分索引列的查找 
   7. 如果有<u>大量重复键</u>值得情况下，哈希索引的效率会很低，因为存在<u>哈希碰撞</u>问题 。   

   二叉树: 

   <u>树的高度不均匀，不能自平衡</u>，查找效率跟数据有关（树的高度），并且IO代价高。

   红黑树： 

   树的高度随着数据量增加而增加，IO代价高。

   

6. ####  聚簇索引与非聚簇索引

   在 InnoDB 里，索引B+ Tree的叶子节点存储了**整行数据**的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。 而索引B+ Tree的叶子节点存储了**主键的值**的是非主键索引，也被称之为非聚簇索引、二级索引。

   区别：

   1. 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）

   2. 对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。

   3.  通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可 

   4. 注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的**主键索引是聚簇索引**，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

      

7. #### 非聚簇索引一定会回表？

   不一定，是否全部命中了索引，称为"覆盖索引"。 

   

8. #### 联合索引？为什么要注意顺序？

   MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要**按照建立索引时的字段顺序**挨个使用，否则无法命中索引。 因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

   

9. #### 最左前缀原则

   建立联合索引时，最左优先。MySQL会一直向右匹配直到**遇到范围查询就停止匹配**。a=1, b=2, c>3 and d = 4 如果建立abcd顺序的索引，d是用不到索引的。如果建立abdc的索引则都可以用到，a,b,d顺序可以调整

   

10. ####  前缀索引

    因为我们索引字段非常长，占内存，不利于维护。使用字符串的前几个字符作为一个索引，使用足够长的字符串以保证较高的选择性。但是order by 不支持前缀索引。

    先计算完整列的选择性 : `select count(distinct col_1)/count(1) from table_1` 

    再计算不同前缀长度的选择性 : `select count(distinct left(col_1,4))/count(1) from table_1` 

    找到最优长度之后，创建前缀索引 : `create index idx_front on table_1 (col_1(4))`

    

11. #### 索引下推

    MySQL 5.6引入了索引下推优化。默认开启，使用`SET optimizer_switch = ‘index_condition_pushdown=off’;`可以将其关闭。 

    有了索引下推优化，**可以在减少回表次数 在InnoDB中只针对二级索引有效** 

    比如在 people_table中有一个二级索引(zipcode，lastname，address)，查询是`SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’`; 

    如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到<u>MySQL服务端</u>，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件 

    如果使用了索引下推技术，**索引为(zipcode, lastname ,address) 的联合索引**，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件， 则根据该索引来定位对应的数据，如果不符合，则直接reject掉。

    

12. #### 怎么查看MySQL语句有没有用到索引

    通过explain。

    

13. #### 为什么推荐使用自增长主键作为索引？

    结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是**减少分裂和移动**的频率。

    

14. ####  如何创建索引

    1. CREAT TABLE 

    2. ALTER TABLE 

       ```sql
       ALTER TABLE table_name ADD INDEX index_name (column_list)
       ```

    3. CREATE INDEX 

       ```sql
       CREATE INDEX index_name ON table_name(column_list);
       ```

       

15. #### 创建索引需要注意什么？

    1. 非空字段：**应该指定列为NOT NULL**，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；

    2. **取离散值大的字段**

    3. **索引字段越小越好**：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大，效率越高

       

16. #### 建立索引的原则

    1. 最左前缀匹配原则

    2. =，in可以乱序

    3. 选择区分度高的列作为索引，区分度公式：count(distinct col)/count(*)

    4. 索引列不能参与计算

    5. 尽量的扩展索引，不要新建索引。

       比如已有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

       

17. ####  使用索引一定能提高查询的性能？

    通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。 

    1. 需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 
    2. 需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。

    使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。 基于非唯一性索引的检索。

    

18. #### 什么情况下索引失效？

    1. 使用**!=或者<>**导致索引失效

    2. 类型不一致导致索引失效

    3. **函数**导致的索引失效（DATE(create_time)）

    4. **运算符**导致的索引失效（+,-,*,/）

    5. **OR**引起的（如果连接的是同一个字段，则不会失效）

    6. 模糊搜索（**like**）

       

19. ####  数据库的三范式

    第一范式：列不可再分。列的原子性，即数据库表的每一列都是不可分割的原子数据项 

    第二范式：属性完全依赖于主键。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 

    第三范式：非主属性不依赖于其它非主属性。

    

20. ####  MySQL支持哪些存储引擎

    MySQL支持多种存储引擎。**InnoDB, MYISAM, Memory, Archive** 其中InnoDB也是MySQL的默认存储引擎

    1. InnoDB支持**事务**，MyISAM不支持

    2. InnoDB支持**外键**，MyISAM不支持

    3. InnoDB是**聚集索引**，数据文件和索引是绑在一起的，必须要有主键，通过主键索引效率很高

       MyISAM是非聚集索引，数据文件分离的， 索引保存的是数据文件的指针，主键索引和辅助索引是独立的

    4. InnoDB**不支持全文索引**，MyISAM支持全文索引，查询效率上MyISAM要高
    5. InnoDB支持**行级锁（默认）和表**级锁，MyISAM支持表级锁

    

    

21. ####  超键，候选键，主键，外键

    超键：能**唯一标识**元组的<u>属性集</u>称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

    候选键：是**最小超键**，即没有冗余元素的超键。 

    主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有 一个主键，且主键的取值不能缺失，即不能为空值（Null）。 

    外键：在**一个表中存在的另一个表的主键**称此表的外键。

    

22. ####  SQL 约束有哪几种？

    NOT NULL，UNIQUE，PRIMARY KEY，FOREIGN KEY，CHECK

    

23. ####  MySQL中in和exists的区别

    MySQL的in语句是把外表和内表做**hash**连接，而exists是对**外表做loop循环**，每次loop循环再对内表查询。**子表大的用exists，子表小的用in**。

    如果使用了not in，内外表都进行**全表扫描，没有用到索引**。而not exists的子查询依然能用到**表上的索引**。用**not exists比not in要快**。

    

24. #### drop, delete, truncate区别

    delete:表结构还在，删除表的一行或全部数据。可回滚。DML。运行速度慢，需要逐行删除

    truncate: 表结构还在，删除表中的所有数据。不可回滚。DDL。删除速度快。

    drop:表结构不再，索引权限都会被删除，不可回滚。DDL。删除速度最快。

    

25. ####  什么是存储过程？优缺点？

    存储过程是**预编译的SQL语句**

    1. 存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
    2. 执行效率比较高，可以降低网络通讯量，提高速率，一定程度上确保安全

    互联网项目中不太推荐因为人员流动和迭代太快，不好管理，复用性不高

    

26. ####  MySQL执行查询的过程

    1. 客户端通过TCP连接发送请求到MySQL连接，连接器会对改请求进行**权限认证**和连接资源分配
    2. **查缓存**：当判断缓存是否命中时，MySQL不会进行解析查询语句，而是使用SQL语句和客户端发送过来的其他原始信息，所以任何字符上的不同（空格或注解）都会导致缓存的不命中
    3. **语法分析**：如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名是否存在歧义
    4. **优化**：是否使用索引，生成执行计划
    5. 交给执行器：将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果返回客户端

    更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。

    

27. #### 什么是数据库事务

    事务是一种不可分割的数据库操作序列。

    

28. #### 事务具有的四个特征（ACID）

    1. 原子性：要么都做要么都不做

    2. 一致性

    3. 隔离性

    4. 持久性

       

29. #### MySQL的四种隔离级别

    1. Read Uncommitted 

    2. Committed Read 

    3. Repeatable Read 

    4. Serializable 

       

30. #### 脏读，幻读，不可重复读

    1. Dirty Read 

    2. Unrepeatable Read

    3. Phantom Read 

       

31. #### 事务的实现原理

    事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。 

    每**提交一个事务**必须先将该事务的所有日志写入到redo log进行**持久化**，数据库就可以通过重做日志来保证事务的**原子性**和**持久性**。 

    每当有**修改事务**时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作， 比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。为了实现**原子性**。

    

32. #### MySQL的事务日志

    Redo log 和 undo log 

    

33. #### 什么是binlog

     MySQL的 binlog 是记录所有**数据库表结构变更**（例如 CREATE、ALTER TABLE）以及**表数据修改** （INSERT、UPDATE、DELETE）的**二进制**日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。 

    MySQL binlog 以**事件**形式记录，还包含语句所执行的**消耗的时间**，MySQL 的二进制日志是**事务安全型**的。binlog 的主要目的是复制和恢复。 

    **binlog 有三种格式**，各有优缺点： 

    1. statement： 基于 **SQL语句**的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在**复制过程可能导致数据不一致甚至出错**。 
    2. row： 基于**行**的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些**大表中清除大量数据时**在 binlog 中会生成很多条语句，可能导致从库延迟变大。 
    3. mixed： 混合模式，根据语句来选用是 statement 还是 row 模式。

    

34. #### 事务中可以混合使用存储引擎吗

    尽量不要在同一个事务中使用多种存储引擎，MySQL事务是由下层的存储引擎实现的。 如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。 但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。

    

35. #### MySQL如何实现事务隔离

    读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。 MySQL在**可重复读级别解决了幻读问题**，是通过**行锁**和**间隙锁**的组合 Next-Key 锁实现的。

    

36. #### 什么是MVCC

    多版本并发控制。通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的

    实现原理：

    对于InnoDB, **聚簇索引**记录中包含3个隐藏的列：

    1. **ROW ID**: 隐藏的自增ID，如果表没有主键，InnoDB会自动按ROW ID产生一个聚集索引树
    2. **事务ID**: 记录**最后一次修改该记录事务的ID**
    3. **回滚指针**：指向**这条记录的上一个版本**

    InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。

    如果要执行更新操作，会将原记录放入undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。 

    MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。

    

37. #### 为什么要加锁

    多个用户并发存取数据，数据库中出现多个事务同时存取同一数据的情况，不加以控制就会破坏数据库的一致性。加锁为了保护多用户下数据的完整性和一致性。

    

38. #### 数据库锁有哪些

    在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎) 和页级锁(BDB引擎 )。 

    行级锁 

    1. MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。 
    2. **开销大**，**加锁慢**；会出现死锁；**锁粒度最小**，发生锁冲突的概率最低，**并发度也最高**。 

    表级锁

    1. MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 
    2. 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 

    页级锁

    1. MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁 

    2. 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

       

39. #### MySQL都有哪些锁

    共享锁：读锁。共享锁可以同时加上多个。

    排它锁：写锁。排它锁只可以加上一个，和其他的共享锁排它锁都互斥

    

40. #### 数据库的乐观锁和悲观锁是什么？怎么实现？

    DBMS并发控制的任务是为了确保事务的原子性，隔离性和数据的一致性。

    乐观锁：假设不会发生并发冲突，只是在提交操作时检查是否违反数据完整性。所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。实现：一般使用**版本号机制**或**时间戳**

    悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来知道提交事务。实现：使用数据库中的锁机制

    

41. #### InnoDB的行锁时怎么实现的

    InnoDB是基于**索引来完成行锁**。例: select * from tab_with_index where id = 1 for update; for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列。

    行级锁都是基于索引的。如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。

    

42. #### 死锁？怎么解决？

    死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 常见的解决死锁的方法

    1. 尽量约定以<u>相同的顺序访问表</u>，可以大大降低死锁机会。 
    2. 在同一个事务中，尽可能做到<u>一次锁定所需要的所有资源</u>，减少死锁产生概率； 
    3. 对于非常容易产生死锁的业务部分，可以尝试使用<u>升级锁定颗粒度</u>，通过表级锁定来减少死锁产生的概率 

    如果业务处理不好可以用分布式事务锁或者使用乐观锁

    

43. #### 优化锁的意见

    1. 使用较低的隔离级别 

    2. 设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突 

    3. 选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话， 最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁 

    4. 不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的 固定顺序的获取表中的行。这样大大的减少死锁的机会。 

    5. 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响 

    6. 不要申请超过实际需要的锁级别

    7. 数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别 

    8. 对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。

       

44. #### 为什么分库分表

    分表

    分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一 个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。就经验单表到几百万的时候， 性能就会相对差一些，需要分表。

    

    分库

    分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发 值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候 就访问一个库好了。

    

45. #### 分库分表中间件？优缺点？

    cobar 

    阿里 b2b 团队开发和开源的，属于 proxy 层方案。早些年还可以用，但是最近几年都没更新了，基本没 啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。 

    TDDL 

    淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。 

    atlas 

    360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新 的维护都在 5 年前了。所以，现在用的公司基本也很少了。 

    sharding-jdbc 

    当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多 限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送 达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以 看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活 跃，个人认为算是一个现在也可以选择的方案。 

    mycat 

    基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。

    

46. #### 如何对数据库进行垂直或水平拆分

    两种分库分表的方式： 

    1. range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。 
    2. 按照某个字段hash一下均匀分散（较为常用） 

    **range 来分**，好处在于说，扩容的时候很简单，给每个月都准备一个库就可以了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。 

    **hash 分发**，好处：可以平均分配每个库的数据量和请求压力；坏处：扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表

    

47. #### 什么是MySQL主从同步

    一个数据库服务器复制到其他的服务器上，一个服务器充当master，其余的服务器充当slave。复制是异步进行的，所以从服务器不需要一直连着主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库甚至是某个数据库上的某个表。

    

48. #### 主从同步的目的

    1. 增加服务器来提高数据库的性能。在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态调整从服务器的数量，从而调整整个数据库的性能。在主服务器上生成实时数据，而在从服务器上分析这些数据，提高主服务器性能

    2. 提高数据安全。可以再从服务器上备份而不住破坏主服务器相应数据

       

49. #### 如何实现MySQL的读写分离

    基于主从复制架构。只写主库，主库会自动把数据同步到从库上，在从库上读。

    

50. #### MySQL主从复制流程和原理

    主：**binlog**线程——记录下所有改变了数据库数据的语句，放进master上的binlog中； 

    从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的**relay log**中； 

    从：sql执行线程——执行relay log（中继日志）中的语句；

    ![主从复制](C:\Users\chens\OneDrive\桌面\面试题\CS Notes\主从复制.PNG)

    

    

51. #### MySQL主从同步延时问题如何解决

    1. 半同步复制：用来解决主库数据丢失问题

       主库写入binlog之后，会强制此时立即将数据同步到从库，从库将日志**写入自己本地的relay log之后就会返回一个ack**给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。

    2. 并行复制：用来解决主从同步延时问题

       **从库开启多个线程，并行读取relay log中不同库的日志**，然后并行重放不同库的日志，这是库级别的并行。

       

52. #### 如何定位及优化SQL语句的性能问题

    查看执行计划。使用EXPLAIN来查看语句的执行计划，显示详细情况，包含了是否使用索引，使用什么索引，使用索引的相关信息

    

53. #### 大表数据查询，怎么优化

    1. 优化schema

    2. SQL语句（限定数据查询的范围，是否加索引）

    3. 加缓存，memcached, redis

    4. 主从复制，读写分离

    5. 分表分库：

       1. 垂直拆分：根据模块的偶尔度，将一个大的系统分为多个小的系统，分布式系统
       2. 水平切分：选择一个合理的sharding key。表结构也要改动，做一定的冗余。SQL中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。

       

54. #### 超大分页怎么处理

    数据库层面也是我们主要集中关注的-**优化大偏移量**

    `select * from table where age > 20 limit 1000000 ,10` 查询其实也是有可以优化的。 这条语句需要 load1000000 数据然后基本上全部丢弃,只取10 条当然比较慢。 

    我们可以修改为 `select * from table where id in (select id from table where age > 20 limit 1000000,10)` 。这样虽然也 load 了一百万的数据，但是由于**索引覆盖**，查询的所有字段都在索引中,所以速度会很快。 

    使用延迟关联，它会让MySQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回表查询需要的所有列。

    解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-v数据库中,直接返回即可。

    

55. #### 慢查询？怎么优化？

    1. 语句分析。看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了 许多结果中并不需要的列，对语句进行分析以及重写。 

    2. 语句的执行计划分析。然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。 

    3. 数据结构。可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

       

56. #### 优化查询过程中的数据访问

    1. 访问数据太多导致查询性能下降 

    2. 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列 

    3. 确认MySQL服务器是否在分析大量不必要的数据行 

    4. 查询不需要的数据。解决办法：使用limit解决

    5. 多表关联返回全部列。解决办法：指定列名

    6. 总是返回全部列。解决办法：避免使用SELECT * 

    7. **重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存** 

    8. 是否在扫描额外的记录。解决办法： 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化： 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。 

    9. 改变数据库和表的结构，修改数据表范式 

    10. 重写SQL语句，让优化器可以以更优的方式执行查询。

        

57. #### 优化关联查询

    1. 确定ON或者USING子句中是否有索引

    2. 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。

       

58. #### 数据库结构优化

    1. 将字段很多的表分解为多个表

    2. 增加中间表

    3. 增加冗余字段

       

59. #### MySQL数据库CPU飙升到500%怎么处理

    先用操作系统命令**top**观察是不是mysqld占用导致的

    如果是mysqld造成的， show processlist， 看看里面session情况，是不是有消耗资源的sql在运行。找出消耗高的sql，看看执行计划是否准确，index是否确实，或是数据量太大导致的。

    kill掉线程看CPU使用率是否下降并进行相应调整（加索引，改SQL， 改内存参数）再重新运行。

    也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 CPU飙升，这种情况就需要跟应用一起来分析为何<u>连接数会激增</u>，再做出相应的调整，比如说限制连接数等。

    

60. #### MyISAM和InnoDB的区别

    1. InnoDB支持**事务**，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

    2. InnoDB支持**外键**，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

    3. InnoDB是**聚集索引**，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构。

    4. InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；InnoDB不支持**全文索引**，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了

    6. MyISAM表格可以被压缩后进行查询操作

    7. InnoDB支持**表、行(默认)级锁**，而MyISAM支持表级锁

    8. InnoDB表**必须有唯一索引**（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而MyISAM可以没有

    9. InnoDB存储文件有frm、ibd（数据文件），而MyISAM是frm（表定义文件）、MYD（数据文件）、MYI（索引文件）

       







##            60道高频MySQL面试题

1. 索引是什么？
2. 索引的优缺点
3. MySQL有哪几种索引类型
4. 索引的底层实现？
5. 为什么索引结构默认使用B+Tree，而不是B-Tree, Hash, 二叉树，红黑树
6. 聚簇索引与非聚簇索引
7. 非聚簇索引一定会回表？
8. 联合索引？为什么要注意顺序？
9. 最左前缀原则
10. 前缀索引
11. 索引下推
12. 怎么查看MySQL语句有没有用到索引
13. 为什么推荐使用自增长主键作为索引
14. 如何创建索引
15. 创建索引需要注意什么？
16. 建立索引的原则
17. 使用索引一定能提高查询的性能？
18. 什么情况下索引失效？
19. 数据库的三范式
20. MySQL支持哪些存储引擎
21. 超键，候选键，主键，外键
22. SQL 约束有哪几种？
23. MySQL中in和exists的区别
24. drop, delete, truncate区别
25. 什么是存储过程？优缺点？
26. MySQL执行查询的过程
27. 什么是数据库事务
28. 事务具有的四个特征（ACID）
29. MySQL的四种隔离级别
30. 脏读，幻读，不可重复读
31. 事务的实现原理
32. MySQL的事务日志
33. 什么是binlog
34. 事务中可以混合使用存储引擎吗
35. MySQL如何实现事务隔离
36. 什么是MVCC
37. 为什么要加锁
38. 数据库锁有哪些
39. MySQL都有哪些锁
40. 数据库的乐观锁和悲观锁是什么？怎么实现？
41. InnoDB的行锁时怎么实现的
42. 死锁Deadlock？怎么解决
43. 优化锁的意见
44. 为什么分库分表
45. 分库分表中间件？优缺点？
46. 如何对数据库进行垂直或水平拆分
47. 什么是MySQL主从同步
48. 主从同步的目的
49. 如何实现MySQL的读写分离
50. MySQL主从复制流程和原理
51. MySQL主从同步延时问题如何解决
52. 如何定位及优化SQL语句的性能问题
53. 大表数据查询，怎么优化
54. 超大分页怎么处理
55. 慢查询？怎么优化？
56. 优化查询过程中的数据访问
57. 优化关联查询
58. 数据库结构优化
59. MySQL数据库CPU飙升到500%怎么处理
60. MyISAM和InnoDB的区别