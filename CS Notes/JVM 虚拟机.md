## JVM 虚拟机

1. #### Java虚拟机

   Java源文件被编译成能被Java虚拟机执行的字节码文件。应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译，因为它知道底层**硬件平台的指令长度和其他特性**。

   

2. #### JRE,JDK,JVM,JIT

   1. JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。

   2. JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。

   3. JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。

   4. JIT 代表即时编译 （Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 

      

3. #### 如何判断JVM是32位还是64位？最大堆内存数是多少？int 类型变量的长度是多少？

   检查某些系统属性如 sun.arch.data.model 或 **os.arch** 来获取该信息。 

   理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多（因为各种条件限制比如交换区，内核地址空间使用，虚拟管理机的管理开销）。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约2G。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小 到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。

   Java中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。

   

4. #### JVM 内存结构

   ![](C:\Users\chens\OneDrive\桌面\面试题\CS Notes\JVM.PNG)

   线程独占：栈，本地方法栈，程序计数器

   线程共享：堆，方法区（类常量池，运行时常量池）

   1. **栈**：又称方法栈，线程私有的。线程执行方法都会创建一个栈帧，用来存储<u>局部变量</u>表，<u>操作数栈</u>，<u>动态连接</u>，<u>方法出口</u>等信息。调用时入栈，方法返回时出栈。

      栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获 的异常）都算作方法结束。 

      操作数栈：用于在方法运行时可以存放以及获取操作数，其所需要的最大栈深度也是在编译期间定下的，在方法刚开始运行时，操作数栈是空的，在方法执行过程中会有各种操作指令往操作数栈中压入和获取内容，也就是出栈/入栈操作，比如一个加法指令对两个数据进行相加，运行到这里前会先将两个数据压入栈中，然后将这两个操作数取出相加；在实际情况中，方法的操作数栈之间并不完全独立，往往会公用部分空间，这样在方法调用时就不需要进行参数复制了

      动态连接：常量池中会存储方法的符号引用，而每个栈帧中都会存储一个引用，用于指向常量池中该方法对应的符号引用，字节码指令中方法的调用就以方法对应的符号引用为参数来进行，在类加载阶段的解析步骤中，部分符号引用会被解析为直接引用，称为**静态解析**，在方法的运行过程中，另一部分<u>符号引用会被实时的解析为直接引用</u>，称为**动态连接**。

   2. **本地方法栈**：执行Java方法时使用栈，执行Native方法时使用本地方法栈。

   3. **程序计数器**：保存着当前线程执行的字节码位置。每个线程工作时都有独立的计数器，<u>只为执行Java方法服务，执行Native方法时，程序计数器为空</u>。

   4. **堆**：JVM内存管理最大的一块，被线程共享。用来存放**对象的实例**。当堆没有可用空间时，会抛出OOM异常

   5. **方法区**（元空间）：又称非堆区,用于存储已被虚拟机加载的<u>类元信息</u>Klass,<u>运行时常量池表</u>,即时编译器优化后的代码等数据。

      **静态变量，字符串常量池**保存在堆中。**类常量池**和**运行时常量池**在方法区中。

      [终于搞懂了Java8的内存结构，再也不纠结方法区和常量池了！ - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1810426)

      

5. #### **成员变量、局部变量、类变量分别存储在内存的什么地方？**

   **类变量**

   - 类变量是用**static**修饰符修饰，定义在方法外的变量，随着java进程产生和销毁
   - 在java8之前把静态变量存放于方法区，在java8时存放在堆中

   **成员变量**

   - 成员变量是定义在类中，但是**没有static**修饰符修饰的变量，随着类的实例产生和销毁，是类实例的一部分
   - 由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象一起放入堆中

   **局部变量**

   - 局部变量是定义在类的方法中的变量
   - 在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟机栈中

   **由final修饰的常量存放在哪里？**

   final关键字并不影响在内存中的位置，具体位置参考以上。

   

6. #### **类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？**

   <u>类常量池</u>与<u>运行时常量池</u>都存储在方法区，而字符串常量池在jdk7时就已经从方法区迁移到了java堆中。

   在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放**字面量**和**符号引用**，而字面量的一部分便是文本字符，在类加载时**将字面量和符号引用解析为直接引用**存储在运行时常量池；比如string.intern()存储在运行时常量池

   对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

   

7. #### **什么是字面量？什么是符号引用？**

   **字面量**

   java代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示:

   ```javascript
   int a=1;//这个1便是字面量
   String b="iloveu";//iloveu便是字面量
   ```

   **符号引用**

   由于在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，所以如果你在一个类中引用了另一个类，那么你完全无法知道他的内存地址，那怎么办，我们只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取他的内存地址。

   例子：我在com.demo.Solution类中引用了com.test.Quest，那么我会把com.test.Quest作为符号引用存到类常量池，等类加载完后，拿着这个引用去方法区找这个类的内存地址。

   

8. #### 什么是JVM内存模型？

   Java内存模型（JMM）在底层处理器内存模型的基础上，定义自己的多线程语义。明确指定了一组排序规则来保证线程的可见性。Happens-Before: 要想保证B操作看到A操作的结果，必须满足：

   1. <u>单线程</u>规则：一个线程中的每个动作都happens-before该线程中的后续每个动作

   2. <u>监视器</u>锁定规则：监听器的解锁动作happens-before后续对这个监听器的锁定动作

   3. <u>volatile</u>变量规则：对volatile字段的写入动作happens-before后续对这个字段的每个读取动作

   4. 线程<u>start</u>规则：start()方法执行happens-before一个启动线程内的任意动作

   5. 线程<u>join</u>规则：一个线程内的所有动作happens-before任意其他线程在该线程join()成功返回之前

   6. 传递性：如果A happens-before B, B happens-before C, 那么A happens-before C

      

9. #### 栈内存溢出

   当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError，方法递归调用时可能会出现该问题。

   解决方案：调用参数**-xss去调整jvm栈**的大小

   

10. #### OOM

       1. OutOfMemoryError: Java heap space 虚拟机中<u>创建的对象太多</u>，进行垃圾回收之前，虚拟机分配的内存已满，与heap space有关
       2. OutOfMemoryError: unable to create new native thread 应用<u>创建了太多线程</u>，一个应用进程创建多个线程，超过系统承载极限，Linux系统默认允许单个线程可创建的线程数是1024个。
       3. OutOfMemoryError: GC overhead limit exceeded。<u>GC回收时间过长</u>时会抛出该异常。过长的定义是超过98%的时间用来做GC并且回收不到2%的堆内存。连续多次出现这种极端情况才会抛出异常。避免恶性循环浪费CPU性能。
       4. OutOfMemoryError: Metaspace。元空间取代永久代，不在虚拟机内存中而是使用本地内存。存放的信息有：类加载信息，常量池，静态变量，即时编译后的代码。方法区溢出，程序中使用了大量的jar或class，或者错误调用string.intern()，使java虚拟机类装载的空间不够

   解决方法：

   1. 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError 

      -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM发生时自动 dump 堆内存信息到指定目录； 

   2. 同时 **jstat** 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域； 

   3. 使用 MAT 工具载入到 dump文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

   4. 使用内存映像分析工具（如Eclipse Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。

   5. 如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 **-Xmx 增加堆大小**

   

11. #### 栈和堆的区别

    栈：**运行时单位，代表着逻辑**。内含基本数据类型和堆中对象引用，所在区域连续，<u>没有碎片</u>；

    堆：**存储单位，代表着数据**，可被多个栈共享（包括成员中基本数据类型，引用和引用对象），所在区域不连续，<u>有碎片</u>。

    1. **功能不同**：栈：存储局部变量和方法调用 

       堆：存储Java对象。无论是成员变量，局部变量还是类变量，它们指向的对象都存储在堆内存中

    2. **共享性不同**：栈：线程**私有**的 堆：所有线程**共享**的

    3. **异常错误不同**：栈：StackOverFlowError 堆：OutOfMemoryError

    4. **空间大小**：栈的空间远远小于堆的

       

12. #### Java对象的创建过程

    1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在<u>常量池中定义到一个类的符号引用</u>，然后加载这个类。 

    2. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)” 

    3. 将除对象头外的对象内存空间初始化为0 

    4. 对对象头进行必要设置

       

13. #### Java对象的结构

    Java对象由三个部分组成：**对象头、实例数据、对齐填充**。 

    1. 对象头由两部分组成：
       1. Mark Word 存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占 32/64 bit）。
       2. Klass Pointer 指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。 
       
    2. 实例数据：用来存储对象真正的有效信息（包括父类继承下来的和自己定义的） 

    3. 对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐 )

       

14. #### 如何判断对象可以被回收

    1. 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，**无法解决对象相互循环引用**的问题。 

    2. 可达性分析（Reachability Analysis）：通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一 个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。 

       第一次标记：判断当前对象是否**有finalize()方法并且该方法没有被执行过**，若不存在则标记为垃圾对象，等待回收；若有的话，则进行**第二次**标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃； **如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收**

       

15. #### JAVA中会存在内存泄漏吗？

    会。自己实现堆载的数据结构时有可能会出现内存泄露，可参看effective java.

    

16. #### GC 是什么？为什么要有GC?

    GC 是垃圾收集。忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 没有提供释放已分配内存的显示操作方法 ，垃圾收集器会自动管理 。要请求垃圾收集，可以调用System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用 。  

    垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 

    

17. #### GC roots对象都有哪些？

    在Java语言中，可作为GC Roots的对象包括4种情况：

    1. **虚拟机栈中引用的对象**（栈帧中的本地变量表）
    2. 方法区中类静态属性引用的对象
    3. 方法区中常量引用的对象
    4. **本地方法栈中**JNI（Native方法）引用的对象

    

18. #### 运行时数据 - 堆（Heap)

    是线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾回收器进行垃圾收集的最重要的内存区域。

    1. **新生代**（1/3）：是用来存放新生的对象。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。Eden：8/10， From Survivor：1/10， To Survivor：1/10

    2. **老年代**（2/3）：主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

    3. **永久代**：指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同，GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

       *在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用<u>本地内存</u>。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。
       
       

19. #### 垃圾回收算法

    1. **标记清除算法（Mark-Sweep）**

    3. **标记整理算法 （Mark - Compact）**

    3. **复制算法（Coping）**

       为了解决算法内存碎片化的缺陷而提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。

    4. **分代收集算法**

       新生代：复制算法。老年代：标记清除或标记整理。根据对象存活的不同生命周期将内存划分为不同的域，老年代和新生代。老年代：每次垃圾回收时只有少量对象需要被回收；新生代：垃圾回收时都有大量垃圾需要被回收。

       

20. #### Minor GC

    Minor GC 采用<u>复制</u>算法（复制 -> 清空 -> 互换）

    新生代因为每次回收都能发现大批对象已死，只有少量存活，因此选用复制算法。只要付出少量存活对象的复制成本就可以完成收集。

    1. Eden, survivorFrom 复制到survivorTo， 年龄加1

       Eden全部都复制到To区， From中只有年龄加1后到达阈值的直接进入老年区，其余复制进入To区

    2. 清空Eden, SurvivorFrom

    3. SurvivorTo 和 SurvivorFrom 互换

       相当于清空SurvivorTo 以进行下一轮循环

    Minor GC <u>触发条件</u>：**Eden区内存不足**

    

21. #### Full GC 

    Full GC 采用<u>标记清除</u>算法

    1. 扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。

    Full GC <u>触发条件</u>：

    1. **调用System.gc**时，系统建议执行Full GC, 但是不是必然执行

       对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间，或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc 

    2. 永久代空间不足（这也是用元空间取代永久代的原因）

       PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanent Generation 可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

    3. **老年代空间不足**

       抛出java.lang.OutOfMemory: Java heap space。调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

    4. 调用Minor GC后进**入老年代的平均大小大于老年代的可用内存**

       Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做 了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。

    5. 由Eden区，From 区向To区复制时，**对象大小大于To区可用内存，则把该对象转存到老年代**，**且老年代的可用内存小于该对象大小。**

       应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为 ms）来避免
       
       

22. ####  对象分配规则

    1. **对象优先分配在Eden区**，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 

    2. **大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象如字符串，数组）。目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 

    3. **长期存活的对象进入老年代**。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之 后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 

    4. **动态判断对象的年龄。**如果**Survivor区**中**<u>相同年龄</u>的所有对象大小的总和大于Survivor空间的一半**，年龄大于或等于该年龄的对象可以直接进入老年代 -XX:TargetSurvivorRatio ，默认为 50%

    5. **空间分配担保**。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则 进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Minor GC, 如果false则进行Full GC 

       

23. #### 空间分配担保

    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure这个参数设置的值(true或flase)是否允许担保失败(如果这个值为true，代表着JVM说，我允许在这种条件下尝试执行Minor GC，出了事我负责)。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlerPromotionFailure为false，那么这次Minor GC将升级为Full GC。

    **-XX:+Handle PromotinoFailure 如果允许担保失败，则只会触发Minor GC， 不然则会同时触发Full GC 。**

    在允许担保失败并尝试进行YoungGC后，可能会出现三种情况： 

    1. YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中 
    2. YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。 
    3. YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些 对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。

    

24. #### GC 垃圾收集器

    ![GC](C:\Users\chens\OneDrive\桌面\面试题\CS Notes\GC.PNG)

    新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法

    1. **Serial**：**复制** + 单线程。新生代

    2. **ParNew**：Serial + 多线程。新生代

    3. **Parallel Scavenge** : 

       复制 + 多线程。新生代。 它重点关注的是程序达到一个 可控制的吞吐量（Throughput， CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。 <u>自适应调节策略</u>也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。 

    4. **Serial Old**: **标记整理** + 单线程。Serial 老年代

    5. **Parallel Old**: **标记整理** + 多线程，Parallel Scavenge的老年代版本。如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old收集器搭配使用。

    6. **Concurrent mark sweep(CMS)**：

       年老代垃圾收集器，并发标记和清除。其最主要目标是获取<u>最短垃圾回收停顿时间</u>， 和其他年老代使用标记-整理算法不同，它使用多线程的<u>标记-清除</u>算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。整个过程分为以下 4 个阶段：  

       1. **初始标记**：只是标记一下 **GC Roots 能直接关联的对象（只关联下一级）**，速度很快，仍然需要暂停所有的工作线程。 (STW)
       2. **并发标记**：**进行 GC Roots 跟踪的过程**，和用户线程一起工作，不需要暂停工作线程。 
       3. **重新标记**：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 (STW)
       4. **并发清除**：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行

       **CMS问题**：

       1. 并发回收导致**CPU资源紧张**。默认启动的回收线程数是(CPU核数+3)/4
       2. **无法清理浮动垃圾**（标记结束后，用户线程可能造成额外垃圾，只能留到下次GC）
       3. **并发失败**：CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了
       4. **内存碎片问题**：在Full GC开启内存碎片的合并整理

    7. **G1（Garbage First）**: 

       垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比CMS 收集器，G1收集器两个最突出的改进是： 

       1. 基于<u>**标记整理**</u>算法，不产生内存碎片。
       2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现**<u>低停顿</u>垃圾回收**。G1 收集器<u>避免全区域垃圾收集</u>，它把堆内存划分为大小固定的**几个独立区域**，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个**优先级列表**，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率
       
       G1 回收器的运作过程大致可分为四个步骤： 
       
       1. 初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的 值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿 线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。 
       2. 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回 收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在 并发时有引用变动的对象。 
       3. 最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。 
       4. **清理阶段（会STW）**：更新Region的统计数据，<u>对各个Region的回收价值和成本进行排序</u>，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。
       
       缺点：
       
       如果应用的内存非常吃紧，对内存进行部分回收根本不够，始终要进行整个Heap的回收，那么G1要做的工作量就一点也不会比其它垃圾回收器少，而且因为本身算法复杂了一点，可能比其它回收器还要差。因此G1比较适合内存稍大一点的应用(一般来说至少4G以上)，小内存的应用还是用传统的垃圾回收器比如CMS比较合适。
       
       **Remembered Set**
       
       我们之前说过，G1在回收每个Region上的垃圾时，每个Region之间又有相互依赖引用关系，想要做到对全部Region进行扫描清理，那么不得不做一次全堆扫描。这样就降低了垃圾回收的效率。所以HotSpot引入了Remembered Set来专门存储于管理对象的引用依赖关系，这样当每次回收时，只需要根据Remembered Set上面的对应关系找到相对的区域进行清理，这样就可以避免扫描整个堆内存又不会遗漏某一个区域。
       
       [一篇文章彻底搞懂CMS与G1 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161204689#:~:text=G1收集器的内存结构完全区别去CMS，弱化了CMS原有的分代模型（分代可以是不连续的空间），将堆内存划分成一个个Region（1MB~32MB%2C,默认2048个分区）%2C这么做的目的是在进行收集时不必在全堆范围内进行。 它主要特点在于达到可控的停顿时间，用户可以指定收集操作在多长时间内完成，即G1提供了接近实时的收集特性。)

    

25. #### Serial 与 Parallel GC 之间的不同之处？

    Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有 一个线程，而parallel 收集器使用多个 GC 线程来执行。 

    

26. #### 永久代会发生垃圾回收吗？

    永久代的垃圾回收主要包括<u>类型的卸载</u>和<u>废弃常量池</u>的回收。

    1. 常量回收：当没有对象引用一个常量的时候，该常量即可以被回收。
    2. 类型卸载：
       1. 该类型的所有实例都被回收。
       
       2. 该类型的ClassLoader被回收。
       
       3. 该类型对应的java.lang.Class没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象。
       
          

27. #### gc log日志user时间为什么比real时间长？

    一般的GC事件中，real time是小于sys+user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys+user time的。比如说：user+sys是2秒，如果是有5个GC线程并发的做垃圾回收，那么real time差不多是2000/5=400ms左右。

    如果user时间比real时间短，可能有以下问题：

    **1.IO负载繁重**
    当服务器的IO负载非常重的时候（网络、磁盘访问、用户交互），real time就会变大。应用做GC日志打印的时候，也需要访问磁盘。当磁盘的负载非常重的时候，GC事件就有可能被阻塞，这会导致real time变长。

    **2.CPU不够用**

    如果服务器上跑了很多进程，你的应用很不幸没有得到足够的CPU时间，它就需要很多的等待。当你的进程在等待的时候，real time显然就比sys+user时间长了。

    

28. #### JVM 类加载机制

    虚拟机把描述类的数据加载到内存，并对数据进行校验，解析和初始化，最终变成可以被虚拟机直接使用的class对象的过程：**加载，连接（验证，准备，<u>解析</u>），初始化，使用，卸载**

    解析阶段则不一定按照以上顺序：它可以在初始化之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）

    JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。 加载完成后，Class对象还不完整，所以此时的类还不可用。 当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引 用）三个步骤。最后JVM对类进行初始化， 包括： 1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类； 2)如果类中存在初始化语句，就依次执行这些初始化语句。  从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的 Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类 加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。

    1. **加载**

       加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

    2. **验证**

       确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害jvm的安全

    3. **准备**

       为class对象的静态变量分配内存，初始化其初始值

    4. **解析**

       将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的： 1. CONSTANT_Class_info 2. CONSTANT_Field_info 3. CONSTANT_Method_info 等类型的常量

    5. **初始化**

       <u>调用类构造器的过程</u>。初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 

        方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成方法。以下情况不会执行类初始化：  

       1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 
       2. 定义对象数组，不会触发该类的初始化。 
       3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 
       4. 通过类名获取 Class 对象，不会触发类的初始化。 
       5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初 始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 
       6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

    6. **使用**

    7. **卸载**

    

29. #### 类加载器（ClassLoader）

    1. **启动类加载器（Bootstrap）**

       负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类

    2. **扩展类加载器（Extension）**

       负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

    3. **应用程序类加载器 （Application）**

       负责加载**用户路径（classpath）**上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义类加载器（User ClassLoader） 
       
       

30. #### 双亲委派

    ![双亲委派](C:\Users\chens\OneDrive\桌面\面试题\CS Notes\双亲委派.PNG)

    一个类收到了类加载请求，<u>不会尝试自己加载，而是把这个请求委派给父类去完成</u>。父类不能完成，子类才会尝试自己加载。启动类是根类。

    好处：比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。

    

31. #### Java 引用

    1. **强引用**：把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。（永远不会被回收）

    2. **软引用**：需要用 SoftReference 类来实现，系统**内存足够时它不会被回收**，不足时才会被回收。通常用在内存敏感的程序。（内存不够时才会被回收）

    3. **弱引用**：需要用 WeakReference 类来实现，它比软引用的生存期更短。只要**垃圾回收**一运行，不管JVM的内存空间足够，总会回收。（垃圾回收机制一运行就会被回收）

    4. **虚引用**：需要用 PhantomRefrence来实现，不能单独使用，必须和引用队列联合使用。主要作用：**跟踪对象被垃圾回收的状态**。

       

32. #### OSGI（动态模型系统）

    OSGI（Open Service Gateway Initiative）， 是面向Java的动态模型系统，是Java动态化模块化系统的一系列规范。

    动态改变构造：OSGI 服务平台提供在多种网络设备上**无需重启的动态改变构造的功能**。为了最小化耦合度，OSGI技术提供一种面向服务的架构，它能使这些组件动态的发现对方。

    模块化编程与热插拔：OSGI旨在为实现Java程序的模块化变成提供基础条件，基于OSGI的程序很可能可以实现**模块级的热插拔功能**，当程序升级更新时，可以只停用，重新安装然后启动程序的<u>其中一部分</u>，这对企业级程序开发来说是非常具有诱惑力的特性。OSGI描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务和架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用OSGI作为基础架构。它在提供强大功能的同时，也引用了额外的复杂度，因为它不遵守了类加载的双亲委托模型。

    

33. #### 列举你知道的打破双亲委派机制的例子，为什么要打破？

    1. JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应 用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类 加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成 高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。 

    2. Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了 才委派给父加载器。 tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的： 对于各个 webapp 中的 class 和 lib ，需要相互隔离，不能出现一个应用中加载的类库会影 响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。 与 jvm 一样的安全性问题。使用单独的 classloader 去装载 tomcat 自身的类库，以免其 他恶意或无意的破坏； 热部署。

    3. OSGi，实现**模块化热部署**，为**每个模块都自定义了类加载器**，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有**平级的类加载器加载**行为。打破的原因是为了实现模块热替换。 

    4. JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到 类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可 以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添 加模块化的特性。

       

34. #### JVM调优命令

    Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo 

    1. **jps**，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 

    2. **jstat**，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、 JIT编译等运行数据。 

    3. **jmap**，JVM Memory Map命令用于生成heap dump文件 

    4. jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 

    5. **jstack**，用于生成java虚拟机当前时刻的线程快照。 

    6. jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

       

35. #### 调优工具

    常用调优工具分为两类：jdk自带监控工具：jconsole和jvisualvm，第三方：MAT(Memory Analyzer Tool)、GChisto。 

    1. jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存， 线程和类等的监控。

    2. jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 

    3. MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Javaheap分析工具，它可以帮助我们查找 内存泄漏和减少内存消耗。

    4. GChisto，一款专业分析gc日志的工具。

       

36. #### JVM性能调优

    1. 设定堆内存大小

       可以通过 java.lang.Runtime 类中与内存相关方法来获取：剩余的内存，总内存及最大堆内存。Runtime.freeMemory() 剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数， Runtime.maxMemory() 返回最大内存的字节数。

    2. -Xmx: 堆内存最大限制

    3. -XX:NewSize 新生代大小。设定新生代大小：新生代太小会有大量对象涌入老年代。

    4. -XX:NewRatio 新生代和老年代占比

    5. --XX:Survivor Ratio 伊甸园空间和幸存者空间的占比

    6. 设定垃圾回收器：新生代：-XX:+UserParNewGC 老生代：-XX:+UseConcMarkSweepGC

       

37. #### JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用?

    当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。 这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。 

    

    



