## 手撕代码

[TOC]



### 排序

![排序算法](C:\Users\chens\OneDrive\桌面\面试题\CS Notes\排序算法.PNG)

#### 插入排序

插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。 按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序 。

```java
// 1. Insertion sort: put the cur val to the left part which is already sorted
// Best: N^2/2 Worst: N-1
public void insertionSort (int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        for (int j = i; j > 0; j--) {
            if (arr[j] < arr[j-1]) {
                swap (arr, j, j-1);
            }
        }
    }
}
```

#### 选择排序

```java
//2. Selection Sort: select the min value and put to the left
public void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int min = i; 
        for (int j = i+1; j < arr.length; j++) {
            if (arr[j] < arr[min]) {
                min = j; 
            }
        }
        swap(arr, min, i);
    }
}
```

#### ShellSort

```java
//3. Shell Sort 
public void shellSort(int[] arr) {
    int h = 1;
    while (h < arr.length / 3) {
        h = 3* h + 1; // 1, 4, 13, 40
    }
    while (h >= 1) {
        for (int i = h; i < arr.length; i++) {
            for (int j = i; j >= h ; j-= h) {
                if (arr[j] < arr[j-h]) {
                    swap(arr, j, j-h);
                }
            }
        }
        h = h / 3;
    }
}
```

#### RadixSort

```java
//4. Radix Sort
	public void radixSort(int[] arr, int n) {
		int m = getMax(arr, n);
		for (int exp = 1; m / exp > 0; exp*=10) {
			countSort(arr,n,exp);
		}
	}
	public int getMax(int[] arr, int n) {
		int mx = arr[0];
		for (int i = 1; i < n; i++) {
			if (arr[i] > mx) mx = arr[i];
		}
		return mx;
	}
	public void countSort(int arr[], int n, int exp) {
		int output[] = new int[n];
		int count[] = new int[10];
		Arrays.fill(count, 0);
		
		for (int i =0; i < n; i++) {
			count[(arr[i]/exp) % 10]++;
		}
		for (int i = 1; i < 10; i++) {
			count[i] += count[i-1];
		}
		for (int i = n-1; i>=0; i--) {
			output[count[(arr[i]/exp) % 10] -1] = arr[i];
			count[(arr[i]/exp) % 10]--;
		}
		for (int i =0; i < n; i++) {
			arr[i] = output[i];
		}
	}

```

#### BubbleSort

```java
//5. Bubble Sort 把最大的元素放到最右边
public void bubbleSort(int[] arr) {
    boolean isSorted = false;
    for (int i = arr.length - 1; i > 0; i--) {
        if (!isSorted) {
            isSorted = true; 
            for (int j = 0; j < i; j++) {
                if (arr[j+1] < arr[j]) {
                    isSorted = false; 
                    swap (arr, j, j+1); 
                }
            }
        }
    }
}
```

#### MergeSort

```java
//6. Merge Sort 
int[] aux;
public void mergeSort(int[] nums) {
    aux = new int[nums.length];
    helper(nums, 0, nums.length -1);
}
public void helper(int[] nums, int l, int h) {
    if (h <= l) {return;}
    int mid = l + (h-l)/2;
    helper(nums, l, mid);
    helper(nums,mid+1,h);
    merge(nums, l, mid, h);
}
public void merge(int nums[], int l, int m, int h){
    int i = l; int j = m + 1;
    for (int k = l; k <= h; k++){
        aux[k] = nums[k];
    }
    for (int k = l; k <= h; k++){
        if (i > m){nums[k] = aux[j++];}
        else if (j > h) {nums[k] = aux[i++];}
        else if (aux[i] <= aux[j]){
			nums[k] = aux[i++];
        } else {nums[k] = aux[j++];}
    }
}
```

#### HeapSort

```java
//7. Heap Sort
	public void heapSort(int[] arr) {
		int n = arr.length; 
		//Build heap
		for (int i = n/2 -1; i>=0; i--) {
			heapify(arr,n, i);
		}
		//One by one extract an element from heap
		for (int i = n-1; i>=0; i--) {
			//Move current root to the end
			swap(arr, 0, i);
			//call heapify on the reduced tree
			heapify(arr, i, 0);
		}
	}
	//heapify a substree rooted at i in the arr 
	public void heapify(int arr[], int n, int i) {
		int largest = i; 
		int l = 2*i + 1; 
		int r = 2*i + 2; 
		if (l < n && arr[l] > arr[largest]) {largest = l; }
		if (r<n && arr[r] > arr[largest]) {largest = r;}
		if (largest != i) {
			swap(arr, largest, i);
			heapify(arr,n,largest);
		}
	}
```

#### Bucket Sort

```java
//8. Bucket Sort
	public static int[] bucketsort(int[] array, int maximum_value)
	{
	//creating an empty array called newbucket which is considered as bucket array
		int[] newbucket = new int[maximum_value + 1];
		//creating another empty array called sorted_array to store the result array
		int[] sorted_array = new int[array.length];
		//traversing through the input array to add each element to the bucket array
		for (int a= 0; a <array.length; a++)
		newbucket[array[a]]++;
		//sorting each element in the bucket array and adding each sorted element in order to the original input array
		int position = 0;
		for (int b = 0; b < newbucket.length; b++)
		for (int c = 0; c < newbucket[b]; c++)
		sorted_array[position++] = b;
		return sorted_array;
	}
	//function to find the maximum value in the input array in order to sort the given array using bucket sort technique
	static int maximumValue(int[] array)
	{
	int maximum_value = 0;
	for (int d = 0; d < array.length; d++)
	if (array[d] > maximum_value)
	maximum_value = array[d];
	return maximum_value;
	}
```

#### Quick Sort

```java
public void quickSort(int[] nums) {
    quickSortHelper(nums, 0, nums.length -1);
}
public void quickSortHelper(int[] nums, int l, int r) {
    if (l >= r) {return;}
    int i = l; int j = r; //left as the pivot
    while (i < j) {
        while (i < j && nums[j--] >= nums[l]);
        while (i < j && nums[i++] <= nums[l]);
        swap(nums, i, j);
    }
    swap(nums, i, l);
    quickSortHelper(nums, l, i-1);
    quickSortHelper(nums, i+1, r);
    //if quick Select, can directly return quickSortHelper (one of the two side)
    //if (i > k) return quickSort(arr, k, l, i - 1);
    //if (i < k) return quickSort(arr, k, i + 1, r);

    //int random = new Random().nextInt(r-l+1)+l如果需要随机选数
}
```

### 数据结构

#### LRU

```java
class LRUCache {
    class DLinkedNode{
        int key; 
        int val;
        DLinkedNode pre; 
        DLinkedNode next; 
        public DLinkedNode(){}
        public DLinkedNode(int key, int val){this.key = key; this.val = val;}
    }
    private void addToHead(DLinkedNode node) {
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    private void removeNode(DLinkedNode node){
        node.pre.next = node.next; 
        node.next.pre = node.pre;
    }
    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
    private DLinkedNode removeTail() {
        DLinkedNode res = tail.pre;
        removeNode(res);
        return res;
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.pre = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.val;
    }

    public void put(int key, int val) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, val);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 val，并移到头部
            node.val = val;
            moveToHead(node);
        }
    }
}
```

#### 红黑树

#### Trie前缀树

```java
class Trie {
    private Trie[] children; 
    private boolean isEnd; 
    /** Initialize your data structure here. */
    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie node = this; 
        for (int i = 0; i < word.length(); i++){
            char c = word.charAt(i);
            int index = c- 'a';
            if (node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null; 
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}
```

#### 堆

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```



### 二叉树

#### 前序遍历（根，左，右）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {return res;}
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
            //remember every root node while tracking the left in a stack,
            //then traverse back the right node of each root node 
        }
        return res;
    }
}
```



#### 中序遍历（左，根，右）

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        Deque<TreeNode> stk = new LinkedList<TreeNode>();
        while (root != null || !stk.isEmpty()) {
            while (root != null) {
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            res.add(root.val); //和前序遍历唯一的区别是res.add()的位置
            root = root.right;
        }
        return res;
    }
}
```



#### 后序遍历（左，右，根）

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {return;}
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}

//迭代
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {return res;}
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```



#### 查找实现

#### 重建二叉树（给前序和中序）

```java
class Solution {
    private Map<Integer, Integer> map; 
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        map = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            map.put(inorder[i], i);
        }
        return helper(inorder, preorder, 0, n-1, 0, n-1);
    }

    public TreeNode helper (int[] inorder, int[] preorder, int m, int n, int k, int l){
        if (k > l){return null;}
        int index = map.get(preorder[k]);
        TreeNode root = new TreeNode(preorder[k]);
        int left_size = index - m; 
        root.left = helper(inorder, preorder, m, index-1, k+1, k + left_size);
        root.right = helper(inorder, preorder, index+1, n, k + left_size +  1, l);
        return root;
    }
}
```



#### Morris遍历二叉树

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    res.add(p1.val);
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                }
            } else {
                res.add(p1.val);
            }
            p1 = p1.right;
        }
        return res;
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        TreeNode predecessor = null;

        while (root != null) {
            if (root.left != null) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root.left;
                while (predecessor.right != null && predecessor.right != root) {
                    predecessor = predecessor.right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor.right == null) {
                    predecessor.right = root;
                    root = root.left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.add(root.val);
                    predecessor.right = null;
                    root = root.right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                    addPath(res, p1.left);
                }
            }
            p1 = p1.right;
        }
        addPath(res, root);
        return res;
    }

    public void addPath(List<Integer> res, TreeNode node) {
        int count = 0;
        while (node != null) {
            ++count;
            res.add(node.val);
            node = node.right;
        }
        int left = res.size() - count, right = res.size() - 1;
        while (left < right) {
            int temp = res.get(left);
            res.set(left, res.get(right));
            res.set(right, temp);
            left++;
            right--;
        }
    }
}
```

#### 求二叉树宽度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root==null){return 0;}
        LinkedList<TreeNode> queue=new LinkedList<TreeNode>();
        int maxwidth=0;
        queue.offer(root);
        root.val=0;
        while(!queue.isEmpty()){
            int count=queue.size();
            int width=queue.getLast().val-queue.getFirst().val+1;
            for(int i=0;i<count;i++){
                TreeNode temp=queue.poll();
                if(temp.left!=null){
                    queue.offer(temp.left);
                    temp.left.val=temp.val*2+1;
                }
                if(temp.right!=null){
                    queue.offer(temp.right);
                    temp.right.val=temp.val*2+2;
                }
            }
            if(width>maxwidth){maxwidth=width;}
        }
         return maxwidth;
    }  
}
```

#### 序列化和反序列化二叉树

```java
public class Codec {

    //use StringBuilder rathern than string 
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null){return "[null]";}
        Queue<TreeNode> queue = new LinkedList<>(); 
        queue.add(root);
        StringBuilder res = new StringBuilder("[");
    
        while(!queue.isEmpty()){
           TreeNode node = queue.poll();
            if (node != null) {
            	res.append(node.val +",");
            	queue.add(node.left);
            	queue.add(node.right);
            } else {res.append("null,");}
        } 
        res.deleteCharAt(res.length() - 1);
        res.append("]");
        return res.toString();
    }


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("[null]")){return null;}
        String[] arr = data.substring(1,data.length()-1).split(",");

        TreeNode root = new TreeNode(Integer.valueOf(arr[0]));
        Queue<TreeNode> queue = new LinkedList<>(){{add(root);}};
        int k = 1;
        while(!queue.isEmpty()){  
            TreeNode node = queue.poll(); 
            if (!arr[k].equals("null")){
                node.left = new TreeNode(Integer.valueOf(arr[k]));
                queue.add(node.left);
            } else {node.left = null;}
            if (!arr[k+1].equals("null")){
                node.right = new TreeNode(Integer.valueOf(arr[k+1]));
                queue.add(node.right);
            } else {node.right = null;}
            k += 2;
        }
        return root;
    } 
}

```

#### 二叉树的层序遍历

```java
class Solution {
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    List<Integer> list = new ArrayList<Integer>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {return ans;}
        bfs(root);
        return ans;
    }
    public void bfs (TreeNode root){
        queue.offer(root);
        while (!queue.isEmpty()){
            int curLevelSize = queue.size(); //levelsize
            for (int i = 0; i < curLevelSize ; i++){
                root = queue.poll();
                list.add(root.val);
                if (root.left != null) queue.offer(root.left);
                if (root.right != null) queue.offer(root.right);
            }
            ans.add(list); 
            list = new ArrayList<Integer>();
        }
    } 
}
```





### 链表

21 合并两个有序[链表]()
23 合并 K 个升序[链表]()
92 反转指定位置[链表]()
25 k 个一组[反转链表]()
61 旋转[链表]()
2 两数相加！！！
19 删除[链表]()倒数第 K 个节点！
19 删除[链表]()的倒数第N个节点 两种实现+图解 中等
21 合并两个有序[链表]() 两种实现+图解 简单
23 合并K个升序[链表]() 四种实现+图解 困难
24 两两交换[链表]()中的节点 三种实现+图解 中等
25 K 个一组翻转[链表]() 两种实现+图解 困难
61 旋转[链表]() 两种实现+图解 中等
82 删除[排序]()[链表]()中的重复元素 II 三种实现+图解 中等
83 删除[排序]()[链表]()中的重复元素 两种实现+图解 简单
141 [二叉树]()展开为[链表]() 四种实现+图解 中等
138 复制带随机指针的[链表]() 两种实现+图解 中等
141 环形[链表]() 两种实现+图解 简单
160 相交[链表]() 两种实现+图解 简单
203 移除[链表]()元素 两种实现+图解 简单
206 [反转链表]() 两种实现+图解 简单
234 回文[链表]() 图解 简单
237 删除[链表]()中的节点 图解 简单
876 [链表]()的中间结点 图解 简单
328 奇偶[链表]()

#### 判断链表是否有环

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode s = head, f = head;
        while(f != null && f.next != null){ 
            s = s.next;
            f = f.next.next;
            if(s == f) return true;
        }
        return false;
    }
}
```

#### 链表中环的入口

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) { //slow和head一起走直到相遇就是入环点
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

#### 删除链表的某个节点

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if(head.val == val) return head.next;
        ListNode pre = head, cur = head.next;
        while(cur != null && cur.val != val) {
            pre = cur;
            cur = cur.next;
        }
        if(cur != null) pre.next = cur.next;
        return head;
    }
}
```

#### 反转单向链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode ptr = head; 
        ListNode pre = null;
        while (ptr != null){
            ListNode temp = ptr.next;
            ptr.next = pre;
            pre = ptr;
            ptr= temp;
        }
        return pre;
    }
}
//反转链表II - 反转left-right区间
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        ListNode cur = pre.next;
        ListNode next;
        for (int i = 0; i < right - left; i++) {
            next = cur.next;//所有都前进一步
            cur.next = next.next;
            next.next = pre.next;//next.next后撤
            pre.next = next;
        }
        return dummyNode.next;
    }
}
```

#### 反转双向链表

```java
public DoubleNode reverseList(DoubleNode head){
	DoubleNode pre=null;
	DoubleNode next=null;
	while(head!=null){
		next=head.next;
		head.next=pre;
		head.pre=next;//different from single direction ListNode
		pre=head;
		head=next;
	}
	return pre;
}
```

#### 链表中倒数第k个节点

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode former = head, latter = head;
        for (int i = 0; i < k; i++) {
            former = former.next;
        }
        while (former != null){
            former = former.next;
            latter = latter.next;
        }
        return latter;
    }
}
```

#### 将每个链表节点右移k个位置

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        int n = 1;
        ListNode iter = head;
        while (iter.next != null) {
            iter = iter.next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter.next = head;//变成环
        while (add-- > 0) {
            iter = iter.next;
        }
        ListNode ret = iter.next;
        iter.next = null;
        return ret;
    }
}
```

#### 排序链表

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null) {return head;}
        int length = 0; 
        ListNode node = head; 
        while (node!= null){length++; node = node.next;}
        ListNode dummyHead = new ListNode (0, head);
        for (int i = 1; i < length; i<<= 1){
            ListNode pre = dummyHead, cur = dummyHead.next; 
            while (cur != null) {
                ListNode head1 = cur; 
                for (int j = 1; j < i && cur.next != null; j++){
                    cur = cur.next;
                }
                ListNode head2 = cur.next;
                cur.next = null;
                cur = head2;
                for (int j = 1; j < i && cur != null && cur.next != null; j++){
                    cur = cur.next;
                }
                ListNode next = null;
                if (cur != null){
                    next = cur.next;
                    cur.next = null; 
                }
                ListNode merged = merge (head1, head2);
                pre.next = merged;
                while (pre.next != null){pre = pre.next;} //pre.next
                //因为后面的merged list要加在pre后面pre.next=... 所以需要pre.next != null
                //需要预留一个节点用来指向后面的节点
                cur = next;
            }
        }
        return dummyHead.next;
    }

    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null){
            if (temp1.val <= temp2.val){
                temp.next = temp1; 
                temp1 = temp1.next;
                temp = temp.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next; 
                temp = temp.next;
            }
        }
        if (temp1 != null){
            temp.next = temp1;
        } else if (temp2 != null){
            temp.next = temp2;
        } 
        return dummyHead.next;
    }
}
```



### 数组

#### 两数/三数之和

```java
//两数之和 O(n) 哈希表
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target-nums[i]))
                return new int[]{map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int[]{0,0};
    }
}
//三数之和 O(n^2) 双指针
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; i++){
            if (i > 0 && nums[i] == nums[i-1]) continue;
            int target = -nums[i];
            int l = i + 1; 
            int r = nums.length - 1;
            while (l < r){
                if (l>i+1 && nums[l] == nums[l-1]) {l++; continue;}
                if (nums[l] + nums[r] < target) l++;
                else if (nums[l] + nums[r] > target) r--;
                else {
                    ArrayList<Integer> lst = new ArrayList<Integer>();
                    lst.add(nums[i]);
                    lst.add(nums[l]);
                    lst.add(nums[r]);
                    ans.add(lst);
                    l++;
                }
            }
        }
        return ans;
    }
}
```



#### 三数之和-closest

```java
//双指针
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int minValue = Math.abs(nums[0] + nums[1] + nums[2] - target); 
        int ans = nums[0] + nums[1] + nums[2];
        Arrays.sort(nums);
        for (int i = 0; i< nums.length; i++){
            int r = nums.length-1;
            int l = i+1;
            while (l<r){
                int value = nums[l] + nums[r] + nums[i] - target;
                if (value == 0){ans = target;return ans;}
                else if (value > 0){
                    if(value < minValue) {
                        minValue = value; ans = value+target;
                    }
                    r--;
                } else {
                    if(Math.abs(value) < minValue){
                        minValue = Math.abs(value); ans = value+target;
                    }
                    l++;
                } 
            }    
        }
        return ans;
    }
}
```



#### 数组中超过一半的数

```java
//随机法：由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。
class Solution {
    private int randRange(Random rand, int min, int max) {
        return rand.nextInt(max - min) + min;
    }
    private int countOccurences(int[] nums, int num) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == num) {
                count++;
            }
        }
        return count;
    }
    public int majorityElement(int[] nums) {
        Random rand = new Random();

        int majorityCount = nums.length / 2;

        while (true) {
            int candidate = nums[randRange(rand, 0, nums.length)];
            if (countOccurences(nums, candidate) > majorityCount) {
                return candidate;
            }
        }
    }
}

//分治：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。
class Solution {
    private int countInRange(int[] nums, int num, int lo, int hi) {
        int count = 0;
        for (int i = lo; i <= hi; i++) {
            if (nums[i] == num) {
                count++;
            }
        }
        return count;
    }

    private int majorityElementRec(int[] nums, int lo, int hi) {
        if (lo == hi) {
            return nums[lo];
        }

        // recurse on left and right halves of this slice.
        int mid = (hi - lo) / 2 + lo;
        int left = majorityElementRec(nums, lo, mid);
        int right = majorityElementRec(nums, mid + 1, hi);

        // if the two halves agree on the majority element, return it.
        if (left == right) {
            return left;
        }

        // otherwise, count each element and return the "winner".
        int leftCount = countInRange(nums, left, lo, hi);
        int rightCount = countInRange(nums, right, lo, hi);

        return leftCount > rightCount ? left : right;
    }

    public int majorityElement(int[] nums) {
        return majorityElementRec(nums, 0, nums.length - 1);
    }
}

//Boyer-Moore投票算法
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
}
```



#### 数组中重复的数字

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int i = 0;
        while (i < nums.length){
            if (nums[i] == i) {i++; continue;}
            if (nums[nums[i]] == nums[i]) {return nums[i];}
            int temp = nums[i];
            nums[i] = nums[temp];
            nums[temp] = temp;
        }
        return -1;
    }
}
```

#### 原地翻转数组

#### 最小的k个数

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k >= arr.length) return arr;
        helper(arr, 0, arr.length -1, k);//如果是第k大/小的数，只需要把k变成k-1
        return Arrays.copyOf(arr, k);
    }
    public void helper(int[] arr, int l, int h, int k){
        if (h <= l) return ;
        int i = l; int j = h;
        //int m = new Random().nextInt(h-l+1)+l;
        //swap(arr, m, l);
        while (i < j){
            while (i < j && arr[j] >= arr[l]){j--;}
            while(i < j && arr[i] <= arr[l]){i++;}
            swap(arr, i, j);
        }
        swap(arr, i, l);
        if (i == k) return;
        if (i > k)  helper(arr,l, i-1, k);
        else {helper(arr, i+1, h, k);}
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### 数组中所有消失的数

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for (int num: nums){
            int x = (num-1) % n;
            nums[x] +=n;
        }
        List<Integer> ans = new ArrayList<Integer>();
        for (int j = 0; j < nums.length ;j++){
            if (nums[j] <= n) ans.add(j+1);
        }
        return ans;
    }
}
```

#### 和为k的连续子数组

```java
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        HashMap<Integer, Integer> mp = new HashMap <> ();
        mp.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (mp.containsKey(pre - k)) {
                count += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```



#### 二分查找

##### 旋转数组中的最小数字

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[right]) left = mid + 1;
            else if (nums[mid] < nums[right]) right = mid;
            else right = right - 1;
        }
        return nums[left];
    }
}
```

##### 二维数组中的查找

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
       if (matrix == null || matrix.length == 0 ||matrix[0].length == 0){
           return false;
       }
       int i = 0, j = matrix[0].length - 1;
       while (i < matrix.length && j >=0){
           if (matrix[i][j] == target) {return true;}
           if (matrix[i][j] > target) j--;
           else {i++;}
       }
       return false;
    }
}
```



### 字符串

#### 字符串的全排列

#### 判断合法ipv4

```java
import java.util.regex.Pattern;
class Solution {
  String chunkIPv4 = "([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  Pattern pattenIPv4 =
      Pattern.compile("^(" + chunkIPv4 + "\\.){3}" + chunkIPv4 + "$");

  String chunkIPv6 = "([0-9a-fA-F]{1,4})";
  Pattern pattenIPv6 =
      Pattern.compile("^(" + chunkIPv6 + "\\:){7}" + chunkIPv6 + "$");

  public String validIPAddress(String IP) {
    if (IP.contains(".")) {
      return (pattenIPv4.matcher(IP).matches()) ? "IPv4" : "Neither";
    }
    else if (IP.contains(":")) {
      return (pattenIPv6.matcher(IP).matches()) ? "IPv6" : "Neither";
    }
    return "Neither";
  }
}
class Solution {
  public String validateIPv4(String IP) {
    String[] nums = IP.split("\\.", -1);
    for (String x : nums) {
      // Validate integer in range (0, 255):
      // 1. length of chunk is between 1 and 3
      if (x.length() == 0 || x.length() > 3) return "Neither";
      // 2. no extra leading zeros
      if (x.charAt(0) == '0' && x.length() != 1) return "Neither";
      // 3. only digits are allowed
      for (char ch : x.toCharArray()) {
        if (! Character.isDigit(ch)) return "Neither";
      }
      // 4. less than 255
      if (Integer.parseInt(x) > 255) return "Neither";
    }
    return "IPv4";
  }

  public String validateIPv6(String IP) {
    String[] nums = IP.split(":", -1);
    String hexdigits = "0123456789abcdefABCDEF";
    for (String x : nums) {
      // Validate hexadecimal in range (0, 2**16):
      // 1. at least one and not more than 4 hexdigits in one chunk
      if (x.length() == 0 || x.length() > 4) return "Neither";
      // 2. only hexdigits are allowed: 0-9, a-f, A-F
      for (Character ch : x.toCharArray()) {
        if (hexdigits.indexOf(ch) == -1) return "Neither";
      }
    }
    return "IPv6";
  }

  public String validIPAddress(String IP) {
    if (IP.chars().filter(ch -> ch == '.').count() == 3) {
      return validateIPv4(IP);
    }
    else if (IP.chars().filter(ch -> ch == ':').count() == 7) {
      return validateIPv6(IP);
    }
    else return "Neither";
  }
}
```



1. 正则表达式匹配：实现一个函数用来匹配包括'.'和'*'的正则表达式

2. 最长公共子串/公共子序列

3. 买卖股票的最佳时机

4. 有向图是否有环

5. 算a+b不能用+，-

6. 括号匹配

7. top k问题

   

### 栈

#### 用固定大小的数组实现栈

#### 如何仅用队列实现栈

#### 最小值栈：能够返回栈中最小元素的栈

#### 栈的压入、弹出序列：

```java
//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序
```

**辅助栈**

矩阵的最小面积
155 最小栈
739 每日温度
剑指 Offer 59 - II 队列的最大值
剑指 Offer 59 - I [滑动窗口的最大值]()
lc 239 [滑动窗口的最大值]()
42 接雨水
496 下一个更大元素 I
503 下一个更大元素 II
1081 不同字符的最小子序列

1. 接雨水（困难） 暴力解法、优化、双指针、单调栈 
2. 每日温度（中等） 暴力解法 + 单调栈 
3. 下一个更大元素 I（简单） 暴力解法、单调栈 
4. 去除重复字母（困难） 栈 + 哨兵技巧（Java、C++、Python） 
5. 股票价格跨度（中等） 「力扣」第 901 题：股票价格跨度（单调栈） 
6. 移掉K位数字 
7. 最短无序连续子数组



### 队列

#### 循环队列

```java
//每次从headIndex删除deQueue，从tailIndex+1添加enQueue
class MyCircularQueue {
  private int[] queue;
  private int headIndex;
  private int count;
  private int capacity;
  /** Initialize your data structure here. Set the size of the queue to be k. */
  public MyCircularQueue(int k) {
    this.capacity = k;
    this.queue = new int[k];
    this.headIndex = 0;
    this.count = 0;
  }

  /** Insert an element into the circular queue. Return true if the operation is successful. */
  public boolean enQueue(int value) {
    if (this.count == this.capacity)
      return false;
    this.queue[(this.headIndex + this.count) % this.capacity] = value;
    this.count += 1;
    return true;
  }

  /** Delete an element from the circular queue. Return true if the operation is successful. */
  public boolean deQueue() {
    if (this.count == 0)
      return false;
    this.headIndex = (this.headIndex + 1) % this.capacity;
    this.count -= 1;
    return true;
  }

  /** Get the front item from the queue. */
  public int Front() {
    if (this.count == 0)
      return -1;
    return this.queue[this.headIndex];
  }

  /** Get the last item from the queue. */
  public int Rear() {
    if (this.count == 0)
      return -1;
    int tailIndex = (this.headIndex + this.count - 1) % this.capacity;
    return this.queue[tailIndex];
  }

  /** Checks whether the circular queue is empty or not. */
  public boolean isEmpty() {
    return (this.count == 0);
  }

  /** Checks whether the circular queue is full or not. */
  public boolean isFull() {
    return (this.count == this.capacity);
  }
}
```

#### 两个栈结构实现队列

```java
class CQueue {
    LinkedList<Integer> A, B;
    public CQueue() {
        A = new LinkedList<Integer>();
        B = new LinkedList<Integer>();
    }
    public void appendTail(int value) {
        A.addLast(value);
    }
    public int deleteHead() {
        if(!B.isEmpty()) return B.removeLast();
        if(A.isEmpty()) return -1;
        while(!A.isEmpty())
            B.addLast(A.removeLast());
        return B.removeLast();
    }
}
```

#### 队列的最大值

```java
class MaxQueue {
    Queue<Integer> q;
    Deque<Integer> d;

    public MaxQueue() {
        q = new LinkedList<Integer>();
        d = new LinkedList<Integer>();
    }
    
    public int max_value() {
        return d.isEmpty() ? -1 : d.peekFirst();
    }
    
    public void push_back(int value) {
        //从队列尾部插入元素时，可以提前取出队列中所有比这个元素小的元素，使得队列中只保留对结果有影响的数字。
        while (!d.isEmpty() && d.peekLast() < value) {
            d.pollLast();
        }
        d.offerLast(value);
        q.offer(value);
    }
    
    public int pop_front() {
        if (q.isEmpty()) {
            return -1;
        }
        int ans = q.poll();
        if (ans == d.peekFirst()) {
            d.pollFirst();
        }
        return ans;
    }
}
```



### 单调栈

#### 单调栈结构的实现

#### 直方图中的最大矩形面积

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        int[] right = new int[n];
        
        Deque<Integer> mono_stack = new ArrayDeque<Integer>();
        for (int i = 0; i < n; ++i) {
            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
                mono_stack.pop();
            }
            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());
            mono_stack.push(i);
        }
        mono_stack.clear();
        for (int i = n - 1; i >= 0; --i) {
            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
                mono_stack.pop();
            }
            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());
            mono_stack.push(i);
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
}
```



#### 求最大子矩阵的大小

```java
//暴力解法优化：
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        if (m == 0) {return 0;}
        int n = matrix[0].length;
        int[][] left = new int[m][n];

        // 辅助数据结构：左边连续的1
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (matrix[i][j] == '1'){
                    if (j == 0) {left[i][j] = 1;}
                    else {left[i][j] = left[i][j-1] + 1;}
                }
            }
        }
        int res = 0, area = 0, width = 0; 
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (matrix[i][j]=='0'){continue;}
                //left[i][j]
                width = left[i][j];
                area = width;
                for (int k = i-1; k >= 0; k--){
                    if (left[k][j] == 0) {break;}
                    width = Math.min(width, left[k][j]);
                    area = Math.max(area, width * (i-k+1));
                }
                res = Math.max(res, area);
            }
        }
        return res;
    }
}
//单调栈
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        if (m == 0) {return 0;}
        int n = matrix[0].length;
        int[][] left = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
                }
            }
        }
        int ans = 0;
        for (int j = 0; j < n; j++) { // 对于每一列，使用基于柱状图的方法
            int[] up = new int[m];
            int[] down = new int[m];
            Deque<Integer> stack = new LinkedList<Integer>();
            for(int i = 0; i < m; i++){
                while(!stack.isEmpty() && left[stack.peek()][j]>= left[i][j]){
                    stack.pop();
                }
                up[i] = stack.isEmpty()? -1:stack.peek();
                stack.push(i);
            }
            stack.clear();
            for (int i=m-1; i>=0; i--){
                while(!stack.isEmpty() && left[stack.peek()][j] >= left[i][j]){
                    stack.pop();
                }
                down[i] = stack.isEmpty()? m:stack.peek();
                stack.push(i);
            }
            for (int i = 0; i < m; i++) {
                int height = down[i] - up[i] - 1;
                int area = height * left[i][j];
                ans = Math.max(ans, area);
            }
        }
        return ans;
    }
}
```



#### 可见山峰问题





### 数字与位运算

#### 两数之和、三数之和（LC1)、最接近的三数之和(LC16)

```java
//两数之和
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(nums[i])){return new int[]{map.get(nums[i]),i};}
            map.put(target - nums[i], i);
        }
        return new int[]{0,0};
    }
}
//三数之和：排序+双指针 （答案不包含重复元素）
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int n = nums.length;
        Arrays.sort(nums);
        for (int i = 0; i < n-1; i++){
            if (i>0 && nums[i]==nums[i-1]){continue;}
            int target = -nums[i];
            int r = n-1; int l = i+1;
            while(l<r){
                if (l > i+1 && nums[l] == nums[l-1]){l++; continue;}
                if (nums[l] + nums[r] < target) {l++;}
                else if (nums[l] + nums[r] > target){r--;}
                else{
                    ArrayList<Integer> lst = new ArrayList<Integer>();
                    lst.add(nums[i]);
                    lst.add(nums[l]);
                    lst.add(nums[r]);
                    ans.add(lst);
                    l++;
                }
            }
            
        }
        return ans;
    }
}
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int minValue =Math.abs(nums[0] + nums[1] + nums[2] - target); 
        int ans = nums[0] + nums[1] + nums[2];
        Arrays.sort(nums);
        for (int i = 0; i< nums.length; i++){
            int r = nums.length-1;
            int l = i+1;
            while (l<r){
                int value = nums[l] + nums[r] + nums[i] - target;
                if (value == 0){ans = target;return ans;}
                else if (value > 0){
                    if(value < minValue) {minValue = value; ans = value+target;}
                    r--;
                } else {
                    if(Math.abs(value) < minValue){minValue = Math.abs(value); ans = value+target;}
                    l++;
                } 
            }    
        }
        return ans;
    }
}
```



#### 大数问题：大数相加(LC415)和大数相乘问题 (LC43)+ Karatsuba 算法

```java
class Solution {//字符串相加
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder("");
        int i = num1.length()-1; int j = num2.length()-1; int carry = 0;
        while (i >= 0 || j >= 0){//>=
            int n1 = i>=0? num1.charAt(i) - '0':0;
            int n2 = j>=0? num2.charAt(j)-'0':0;
            int add = (n1 + n2 + carry) % 10; //remember to plus carry for both add and carry
            carry = (n1+n2+carry)/10;
            res.append(add);
            i--;j--;
        }
        if (carry == 1) {res.append(1);}
        return res.reverse().toString();
    }
}
class Solution {
    //竖式每一位相乘num1[i] * num2[j] 
    public String multiply(String num1, String num2){
        if (num1.equals("0") || num2.equals("0")){return "0";}
        int[] res = new int[num1.length() + num2.length()];
        for (int i = num1.length() - 1; i >=0; i--){
            for (int j = num2.length() -1; j>=0; j--){
                int n1 = num1.charAt(i) - '0';
                int n2 = num2.charAt(j)-'0';
                int sum = res[i+j+1] +n1 *n2;
                res[i+j+1] = sum % 10;
                res[i+j] += sum / 10;
            }
        }
        StringBuilder result = new StringBuilder();
        for (int i =0; i <res.length; i++){
            if (i == 0 && res[i] == 0) {continue;}
            result.append(res[i]);
        }
        return result.toString();
    }
}
```



#### 打印从 1 到最大的 n 位数

#### 数值的整数次方pow(x,N) 快速幂

```java
class Solution {
    public double myPow(double x, int n) {
        if(x == 0.0d) return 0.0d;
        long b = n;
        double res = 1.0;
        if(b < 0) {x = 1 / x;b = -b;}
        while(b > 0) {
            if((b & 1) == 1) res *= x;
            x *= x;
            b >>= 1;
        }
        return res;
    }
}
```

#### 二进制中 1 的个数

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0; 
        while (n != 0){
            if ((n&1) == 1) res++;
            n = n>>>1;
        }
        return res;
    }
}
```



### 贪心算法



45 跳跃游戏II
55 跳跃游戏
435 无重叠子区间
1784 检查二进制字符串字段
1785 构成特定和需要添加的.....



### 动态规划



509 斐波那契数
70 爬楼梯
746 使用最小花费爬楼梯
121 [买卖股票的最佳时机]()
122 [买卖股票的最佳时机]()
123 [买卖股票的最佳时机]()
\322. 零钱兑换
\518. 零钱兑换
64 最小路径和
198 打家劫舍
213 打家劫舍 II
5 [最长回文子串]()
120 三角形最小路径和
lc 673. [最长递增子序列]()的个数
lc 300. [最长递增子序列]()
\62. 不同路径（中等）：路径问题第一讲
\63. 不同路径 II（中等）：路径问题第二讲
\64. 最小路径和（中等）：路径问题第三讲
\120. 三角形最小路径和（中等）
\931. 下降路径最小和（中等）
1289 下降路径最小和 II（困难）
\1575. 统计所有可行路径（困难）
\576. 出界的路径数（中等）
\1301. 最大得分的路径数目（困难）
\647. 回文子串
\5. [最长回文子串]()
718 最长重复子数组
1143 最长重复子序列
678 有效的括号字符串



#### 正则表达式匹配

```java
class Solution {
    public boolean isMatch(String s, String p) {
        // if not * : dp[i][j]  = dp[i-1][j-1] if s[i] = p[j]
        //            dp[i][j] = false;
        // if *: dp[i][j] = dp[i-1][j] or dp[i][j-2] if s[i] = p[j-1]
        //       dp[i][j] = dp[i][j-2] if not 
        int m = s.length(),n = p.length();
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int i = 0; i <= m; i++){ //start from 0 //dp[0,2] = true;
            for (int j = 1; j <= n; j++){
                if (p.charAt(j-1) != '*'){
                    if (i != 0 && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.')){
                        dp[i][j] = dp[i][j] || dp[i-1][j-1];
                    } 
                } else {
                    dp[i][j] = dp[i][j] || dp[i][j-2];
                    if (i != 0 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.')){
                        dp[i][j] = dp[i][j] || dp[i-1][j];
                    } 
                }
            }
        }
        return dp[m][n];
    }
}
```



### DFS/BFS

#### 岛屿数量(LC200)

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == '1'){
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    private void dfs(char[][] grid, int i, int j){
        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}

class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == '1'){
                    bfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    private void bfs(char[][] grid, int i, int j){
        Queue<int[]> list = new LinkedList<>();
        list.add(new int[] { i, j });
        while(!list.isEmpty()){
            int[] cur = list.remove();
            i = cur[0]; j = cur[1];
            if(0 <= i && i < grid.length && 0 <= j && j < grid[0].length && grid[i][j] == '1') {
                grid[i][j] = '0';
                list.add(new int[] { i + 1, j });
                list.add(new int[] { i - 1, j });
                list.add(new int[] { i, j + 1 });
                list.add(new int[] { i, j - 1 });
            }
        }
    }
}
```



### 拓扑排序

#### 课程表

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        List<List<Integer>> adjacency = new ArrayList<>();
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++){
            adjacency.add(new ArrayList<>());
        }
        for (int[] p: prerequisites){
            indegrees[p[0]]++;
            adjacency.get(p[1]).add(p[0]);
        }
        for (int i = 0; i < numCourses; i++){
            if(indegrees[i] == 0) queue.add(i);
        }
        while(!queue.isEmpty()){
            int pre = queue.poll();
            numCourses--;
            for (int cur: adjacency.get(pre)){
                if (--indegrees[cur] == 0) queue.add(cur);
            }
        }
        return numCourses == 0;
    }
}

class Solution {
    int[] result;
    int k;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adjacency = new ArrayList<>();
        result =  new int[numCourses];
        k = numCourses;
        for(int i = 0; i < numCourses; i++)
            adjacency.add(new ArrayList<>());
        int[] flags = new int[numCourses];
        for(int[] cp : prerequisites)
            adjacency.get(cp[1]).add(cp[0]);
        for(int i = 0; i < numCourses; i++)
            if(!dfs(adjacency, flags, i)) return new int[]{};
        return result;
    }
    private boolean dfs(List<List<Integer>> adjacency, int[] flags, int i) {
        if(flags[i] == 1) return false;
        if(flags[i] == -1) return true;
        flags[i] = 1;
        for(Integer j : adjacency.get(i))
            if(!dfs(adjacency, flags, j)) return false;
        flags[i] = -1;
        result[--k]=i;
        return true;
    }
}
```



### 矩阵

#### 顺时针打印矩阵

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0 ||matrix[0].length == 0) return new int[0];
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length -1, x= 0;
        int[] res = new int[(r+1) * (b+1)];
        while (true) {
            for (int i = l; i <= r; i++) res[x++] = matrix[t][i];
            if (++t>b) break;
            for (int i = t; i <= b; i++) res[x++] = matrix[i][r];
            if (--r<l) break;
            for (int i = r; i >=l; i--) res[x++] = matrix[b][i];
            if (--b<t) break;
            for (int i = b; i >= t; i--) res[x++] = matrix[i][l];
            if (++l>r) break;
        }
        return res;
    }
}
```

#### 将一个正方形旋转 90 度

#### 之字型打印矩阵



### 双指针

lc 27 移除元素
lc 209 长度最小的子数组
lc 141 环形[链表]()
lc 142 环形[链表]()
lc 328 奇偶[链表]()
lc 160 相交[链表]()
lc 21 合并两个有序[链表]()
lc 88 合并两个有序数组
lc 15 三数之和
lc 18 四数之和
lc 83 删除[排序]()[链表]()中的重复元素
lc 673. [最长递增子序列]()的个数
lc 300. [最长递增子序列]()
\1004. 最大连续1的个数 III



### 滑动窗口

作者：酱香脆皮鸡
链接：https://www.nowcoder.com/discuss/825146
来源：牛客网



3 无重复字符的最长子串
209 长度最小的子数组
53 最大子序和
84 柱状图中最大的矩形
239 [滑动窗口的最大值]()
424 替换后的最长重复字符
1004 最大连续1的个数 III
1438 绝对差不超过限制的最长连续子数组
5682 lc 周赛 所有子字符串的美丽值
剑指 Offer 41 [数据]()流中位数
剑指 Offer 42 [连续子数组的最大和]()
剑指 Offer 59 - I [滑动窗口的最大值]()

1. 无重复字符的最长子串 
2. 串联所有单词的子串 
3. [最小覆盖子串]() 
4. 至多包含两个不同字符的最长子串 
5. 至多包含 K 个不同字符的最长子串 
6. 长度最小的子数组 
7. 滑动窗口最大值 
8. [字符串的排列]() 
9. 最小区间 
10. 最小窗口子序列



#### 最小覆盖子串

```java
class Solution {
    Map<Character, Integer> map1 = new HashMap<Character, Integer>();
    Map<Character, Integer> map2 = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int m = s.length(), n = t.length();
        for (int i = 0; i < n; i++) {
            char c = t.charAt(i);
            map1.put(c, map1.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int min = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        while (r < m) {
            ++r; //向右滑动 yeah
            if (r < m && map1.containsKey(s.charAt(r))) {
                map2.put(s.charAt(r), map2.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) {
                if (r - l + 1 < min) {
                    min = r - l + 1;
                    ansL = l;
                    ansR = l + min;
                }
                if (map1.containsKey(s.charAt(l))) {
                    map2.put(s.charAt(l), map2.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        for (Character c: map1.keySet()){
			if (map2.getOrDefault(c,0) < map1.get(c)) return false;
        }
        return true;
    }
}
```



### 多线程

#### 按序打印

```java
class Foo {

  private AtomicInteger firstJobDone = new AtomicInteger(0);
  private AtomicInteger secondJobDone = new AtomicInteger(0);

  public Foo() {}

  public void first(Runnable printFirst) throws InterruptedException {
    // printFirst.run() outputs "first".
    printFirst.run();
    // mark the first job as done, by increasing its count.
    firstJobDone.incrementAndGet();
  }

  public void second(Runnable printSecond) throws InterruptedException {
    while (firstJobDone.get() != 1) {
      // waiting for the first job to be done.
    }
    // printSecond.run() outputs "second".
    printSecond.run();
    // mark the second as done, by increasing its count.
    secondJobDone.incrementAndGet();
  }

  public void third(Runnable printThird) throws InterruptedException {
    while (secondJobDone.get() != 1) {
      // waiting for the second job to be done.
    }
    // printThird.run() outputs "third".
    printThird.run();
  }
}
class Foo {

    Semaphore s12 = new Semaphore(0);
    Semaphore s23 = new Semaphore(0);

    public Foo() {}

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        s12.release();//释放后s12的值会变成1
    }

    public void second(Runnable printSecond) throws InterruptedException {
        s12.acquire();//没有会阻塞  当为1的时候，说明线程2可以拿到s12了
        printSecond.run();
        s23.release();//释放后s23的值会变成1
    }

    public void third(Runnable printThird) throws InterruptedException {
        s23.acquire();//0的时候拿不到，1的时候可以拿到
        printThird.run();
    }
}
```

交替打印foobar

```java
class FooBar {
    private int n;

    private Semaphore fooSema = new Semaphore(1);
    private Semaphore barSema = new Semaphore(0);

    public FooBar(int n) {
        this.n = n;
    }
    public void foo(Runnable printFoo) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            fooSema.acquire();//值为1的时候，能拿到，执行下面的操作
            printFoo.run();
            barSema.release();//释放许可给barSema这个信号量 barSema 的值+1
        }
    }
    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            barSema.acquire();//值为1的时候，能拿到，执行下面的操作
            printBar.run();
            fooSema.release();//释放许可给fooSema这个信号量 fooSema 的值+1
        }
    }
}
```

